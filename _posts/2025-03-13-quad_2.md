---
layout: single
title: "[Quad] 2. Authentication, ResponseCode and type definitions."
categories: quad
tag: [ERD, API docs, DML, DDL]
author_profile: false
---

<img src="/images/2025-03-13-quad_2/DSC1200.jpg" alt="_DSC1200" style="zoom:25%;" />

## **Three Ways to Implement Authentication** 

Before implementing user sign-in and sign-up, we need to decide on an authentication method. Generally, there are three common authentication approaches:
1. **Basic authentication**: This method involves sending the userâ€™s credentials (user ID and password) encoded in `Base64` with every request. While it is simple to implement, several critical issues make it unsuitable:

   1. Insecure: Basic authentication transmits credentials in an encoded format, **not encrypted.** Encoding is reversible, meaning **attackers can easily decode and retrieve user credentials**.
   2. Lack of session management: Since there is no session or token-based authentication, **users must send their credentials with every request.** This results in a poor user experienceðŸ˜¡, as users have to repeatedly enter their credentials for every interaction, such as liking or commenting. 

2. **OAuth Authentication**: Many of you have likely signed up for a website using third-party providers such as Google or GitHub. This process is implemented using `OAuth authentication`. **`OAuth` allows users to sign in using external identity providers (e.g., Google, GitHub) without directly handling their credentials.**

   However, I have decided not to use `OAuth` for `Quad` because I will not be integrating third-party authentication services. Although `OAuth` can also support internal authentication systems, implementing it requires significantly more time and effort compared to the next authentication method I will introduce.

3. Bearer Token: When a client signs in, the server generates and transmits a `Bearer Token` to the client. This token remains valid until its expiration time set within the token.

   Once the client receives the `Bearer Token`, it can use it for authentication by attaching it to the `HTTP request header` when accessing protected resources. This is a example of an `HTTP request header` with a `Bearer Token`:

   ```bash
   Authorization: Bearer <token>
   ```

   I will implement `Bearer Token` authentication using `JWT` (JSON Web Token), which provides secure and stateless authentication. It ensures security through encryption with specific algorithms, and its stateless nature eliminates the need for servers to store session data. This means the server doesnâ€™t need to query the database for each request, resulting in faster and more efficient authentication.

## JWT...? Who are you?

1. ### How is a JWT token structured?

   `Jwt` is consist of three parts, separated by dots(.):

   ```bash
   <Header>.<Payload>.<Signature>
   ```

   ```bash
   eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ1c2VyQGV4YW1wbGUuY29tIiwicm9sZSI6ImFkbWluIiwiZXhwIjoxNzEwOTUwNDAwfQ.H0VlMa2UNxIl_6Im7vx2gCy0j2sr_vsaKdmX9EoIqKw
   ### This is what a JWT looks like.
   ### Try to find the two dots separating the JWT sections!
   ```

   1. Header: This section defines the signing algorithm. I chose a **symmetric key algorithm** because itâ€™s simpler to implement than **asymmetric key algorithms.** ðŸ˜‚
   2. Payload: It contains **data fields**, such as user data and `JWT` expiration time. âœ… Every payload properties are called `claims`. 
   3. Signature: The signature is generated when the `JWT` is created. It is formed by encrypting the header and payload using the serverâ€™s `secret key`. Once created, the signature cannot be altered.

2. ### How is JWT used for authentication?

   <img src="/images/2025-03-13-quad_2/IMG_2646.jpg" alt="IMG_2646" style="zoom:25%" class="align-center" />

   1. The client signs in with a username and password and sends an `HTTP request` to the server for authentication.
   2. The server verifies whether the provided credentials are valid by checking them against the database.
   3. If valid, the server generates a `JWT`, and sends it to the client in an `HTTP response` as a`JSON` object.
   4. Once the client stores the `JWT`, it is used as a `Bearer Token` for authentication.
   5. For future requests, the client includes the `Bearer Token` in the `HTTP` headers until the `JWT` expires.
   6. When the client sends a request with the `Bearer Token`, the server verifies the `JWT`. If the token is valid and not expired, the server processes the request; otherwise, it rejects it.

## JWT Generation and Validation in Spring Boot

Now that weâ€™ve covered the theory, letâ€™s take a look at how `JWT` is created and validated in practice by going through the code. I will introduce two Java classes: JwtAuthenticationFilter and `JwtProvider`.

In `Spring Boot`, when a user sends a request, it passes through filters before reaching the controller. **Filters act as a security layer**, verifying whether the request is valid. Obviously, `JwtAuthenticationFilter` is one such filter that checks if the provided` JWT` is valid.

Meanwhile, **`JwtProvider` is responsible for handling `JWT` operations**, including token creation and validation.

1. ### JwtProvider

   ```java
   @Component
   public class JwtProvider {
       
     	// Declared the secret-key in the application-properties for security reasons.
       @Value("${secret-key}")
       private String secretKey;
     
       public String create(String upi){
     	   ...
       }
   
       public String validate(String jwt){
          ...
       }
   }
   ```

   1. create(String upi)

      ```java
       public String create(String upi){
              Date expiredDate = Date.from(Instant.now().plus(1, ChronoUnit.HOURS));
              Key key = Keys.hmacShaKeyFor(secretKey.getBytes(StandardCharsets.UTF_8));
      
              String jwt = Jwts.builder()
                  .signWith(key, SignatureAlgorithm.HS256)
                  .setSubject(upi).setIssuedAt(new Date()).setExpiration(expiredDate)
                  .compact();
      
              return jwt;
          }
      ```

      This method generates Jwt by setting an expiration time, signing JWT using a secret key and embedding upi within the token.

   2. validate(String jwt)

      ```java
      public String validate(String jwt){
              Claims claims = null;
              Key key = Keys.hmacShaKeyFor(secretKey.getBytes(StandardCharsets.UTF_8));
        
              try {
                  claims = Jwts.parserBuilder()
                      .setSigningKey(key)
                      .build()
                      .parseClaimsJws(jwt)
                      .getBody();
              } catch (Exception exception){
                  exception.printStackTrace();
                  return null;
              }
        
              return claims.getSubject();
          }
      ```

      Validate method is invoked by `jwtAuthenticationFilter`. It checks if `JWT` is signed with the correct secret key; moreover extracts and returns claims(payload) if the the signature is valid.

2. ### JwtAuthenticationFilter

   ```java
   @Component
   @RequiredArgsConstructor
   public class JwtAuthenticationFilter extends OncePerRequestFilter{
   
       private final JwtProvider jwtProvider;
   
       @Override
       protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
         ...
       }
   
       private String parseBearerToken(HttpServletRequest request){
   			...
   }
   ```

   1. doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)

      ```java
      @Override
          protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
                  throws ServletException, IOException {
      
              try {
      
                  String token = parseBearerToken(request);
      
                  if (token == null) {
                      filterChain.doFilter(request, response);
                      return;
                  }
      
                  String upi = jwtProvider.validate(token);
                  if (upi == null) {
                      response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
                      response.setContentType("application/json");
                      response.getWriter().write("{ \"code\":\"Invalid Token\", \"message\": \"Token validation failed.\"}");
                      return;
                  }
      
                  AbstractAuthenticationToken authenticationToken = 
                      new UsernamePasswordAuthenticationToken(upi, null, AuthorityUtils.NO_AUTHORITIES);
                  authenticationToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
      
                  SecurityContext securityContext = SecurityContextHolder.createEmptyContext();
                  securityContext.setAuthentication(authenticationToken);
      
                  SecurityContextHolder.setContext(securityContext);
      
              } catch(Exception exception) {
      
                  exception.printStackTrace();
                  response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
                  response.setContentType("application/json");
                  response.getWriter().write("{ \"code\":\"Auth Error\", \"message\": \"" + exception.getMessage() + "\"}");
                  return;
              }     
      
              filterChain.doFilter(request, response);
          }
      ```

      Validates the `JWT` using the validate method in `JwtProvider` and stores the extracted user information in the `Security Context`, making it accessible across the application. Finally, filterChain.doFilter(request, response); ensures the request proceeds to the next filter or reaches the controller.

   2. parseBearerToken(HttpServletRequest request)

      ```java
      private String parseBearerToken(HttpServletRequest request){
      
              String authorization = request.getHeader("Authorization");
      
              boolean hasAuthorization = StringUtils.hasText(authorization);
              if (!hasAuthorization) return null;
      
              boolean isBearer = authorization.startsWith("Bearer ");
              if(!isBearer) return null;
      
              String token = authorization.substring(7);
              return token;
          }
      ```

      Extracts the `JWT` from the request header.